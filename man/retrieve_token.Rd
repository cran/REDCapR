% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/retrieve-token.R
\name{retrieve_token}
\alias{retrieve_token}
\alias{retrieve_token_mssql}
\title{Read a token from a (non-REDCap) database.}
\usage{
retrieve_token_mssql(project_name, dsn = NULL, channel = NULL)
}
\arguments{
\item{project_name}{The friendly/shortened name given to the REDCap project in the MSSQL table.  Notice this isn't necessarily the same name used by REDCap. Required}

\item{dsn}{A \href{http://en.wikipedia.org/wiki/Data_source_name}{DSN} on the local machine that points to the desired MSSQL database. Required.}

\item{channel}{An \emph{optional} connection handle as returned by \code{\link[RODBC:odbcConnect]{RODBC::odbcConnect()}}.  See Details below. Optional.}
}
\value{
The token, which is a 32 character string.
}
\description{
This function will soon be deprecated; please transition to \code{\link[=retrieve_token_mssql]{retrieve_token_mssql()}}. These functions are not essential to calling the REDCap API, but instead are functions that help manage tokens securely.
}
\details{
If no \code{channel} is passed, one will be created at the beginning of the function, and destroyed at the end.  However if a channel
is created, it's the caller's responsibility to destroy this resource.  If you're making successive calls to the database, it might
be quicker to create a single \code{channel} object and batch the calls together.  Otherwise, the performance should be equivalent.

If you create the \code{channel} object yourself, consider wrapping calls in a \code{base::tryCatch} block, and closing the channel in
its \code{finally} expression; this helps ensure the expensive database resource isn't held open unnecessarily.  See the internals of
\code{\link[=retrieve_token_mssql]{retrieve_token_mssql()}} for an example of closing the \code{channel} in a \code{tryCatch} block.

If the database elements are created with the script provided in package's 'Security Database' vignette, the default values will work.
}
\note{
We use Microsoft SQL Server, because that fits our University's infrastructure the easiest.  But this approach theoretically can work
with any LDAP-enabled database server.  Please contact us if your institution is using something other than SQL Server, and
would like help adapting this approach to your infrastructure.

There's a lot of error checking for SQL injection, but remember that the user is executing under their
own credentials, so this doesn't obviate the need for disciplined credential management.  There's nothing
that can be done with this R function that isn't already exposed by any other interface into the database
(eg, SQL Server Management Studio, or MySQL Workbench.)
}
\examples{
library(REDCapR) #Load the package into the current R session.
\dontrun{
# ---- SQL Server Example ----------------------------
# Rely on `retrieve_token()` to create & destory the channel.
dsn      <- "TokenSecurity"
project  <- "DiabetesSurveyProject"
token    <- retrieve_token(dsn=dsn, project_name=project)

# Create & close the channel yourself, to optimize repeated calls.
dsn      <- "TokenSecurity"
project1 <- "DiabetesSurveyProject1"
project2 <- "DiabetesSurveyProject2"
project3 <- "DiabetesSurveyProject3"

channel  <- RODBC::odbcConnect(dsn=dsn)
token1   <- retrieve_token(dsn=dsn, project_name=project1)
token2   <- retrieve_token(dsn=dsn, project_name=project2)
token3   <- retrieve_token(dsn=dsn, project_name=project3)
RODBC::odbcClose(channel)
}
}
\author{
Will Beasley
}
